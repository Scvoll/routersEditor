Q1 "О хорошем/плохом клиентском приложении" :

Пишу со стороны хорошего приложения.

Я пользователь: 

  Приложение быстро открылось, и все элементы подгрузились.
  Скорость мне очень важна. Я не хочу ждать. Интуитивно понятно, что где находится,
  и куда нажимать. Есть быстрый поиск. Приятный глазу интерфейс. Шрифт читаемый. Нет рекламы.
  Поддерживает родной язык. Когда я даю задание приложению, то вижу, что оно выполняется,
  и сколько осталось до конца. Во время работы ничего не подвисает.
  Да ещё и под разные мои девайсы адаптируется. Приложение отличное.

Я менеджер проекта:

  Приложение сдали в срок. Заказчик доволен. Работники довольны. Нам не стыдно. 
  В процессе работы нагрузка была грамотно распределена. Все покрыли тестами и задокументировали. 
  Был постоянный мониторинг разработки. Риск возникновения багов - минимален.
  Если через год предложат вводить новый функционаонал, то мы согласимся, так как приложение
  сделали расширяемым, а код легко читаемым.
  
Я дизайнер:
  
  Дизайн приложения выглядит органично. Хорошо подбран шрифт и его размер. Текст написан без ошибок.
  Цвет разных элементов сочетается друг с другом. Нет ярко выделающихся фрагеметнов, либо
  наоборот, еле заметных. Все элементы чётко и грамотно распределены,
  чтобы пользователю было просто и понятно работать с интерфейсом, а верстальщику
  понимать границы элементов и их местоположение. Также не менее важная часть - 
  запоминаемость макета. Дизайн приложения, как и лицо человека остается в голове,
  если вызвало интерес.

Я верстальщик: 
  
  Верстка придерживается модели дерево-узел(DOM). Названия классов хорошо ориентурют по местонахождению
  элементов. Нет жесткой связи блоков между собой. Если удалить один блок, то верска не сыпется.
  При изменении размеров экрана элементы сопутствуют правилам Отзывчивой вёртски - резиново сужаются/расширяются 
  и в "ответсвенные моменты" перерисовываются с измененим рамеров и расположения. 
  Иногда исчезают вовсе(текстовое меню на экране, а на телефоне бургер-меню)
  При этом элементы не наезжают друг на друга, а содержимое не вываливается наружу.
  Приложение, как и процессы анимации в нём, отображается одинаково во всех браузерах. Стили грамотно структурированы и 
  вынесены в отдельный файл так же, как и скрипты. Отсутствуют инлайновые объявления css в узлах DOM. 
  
Я серверный программист:
  
  Приложение имеет понятную и удобную архитектуру. Всё, что должно быть скрыто или защищено от использования - инкапсулировано.
  Весь код покрыт тестами. Приложение придерживается 5 принципов ООП - SOLID(без злоупотреблений, конечно).
  Исходя из этого, оно будет гибким, легко расширяться и поддерживаться в будущем. Сложные места закомментированы.
  Логика приложения разделена согласно одному из паттернов проектирования (MVC,MVP,MVVM).
  Отсутствует мертвый код. API построено с учетом архитектурного стиля REST.
  
 
Q2 "Особенности разработки крупных многостраничных сайтов"
  
  Опыта работы с такими крупными проектами не имею, но расскажу, как я это вижу, исходя из опыта над проектами меньшего
  размера и технологиями, которые там использовались.

  Считаю, что в основе любого проекта, над которым будет работать много людей, должна изначально стоять коммуникация между рабочими,
  открытое общение и грамотный наставник(проект менеджер). В идеале у сотрудников должна быть корреляция hard skills и soft skills.
  
  С технической стороны разработки сюда хорошо впишутся ответы на предыдущий вопрос от лиц разных работников.
  Архитектура, сопутствие паттернам, тесты - всё это даёт гибкость в будущем изменении в функциональности и легкость поддрежки.
  
  Использование сборщиков(webpack/gulp). Мощный механизм, позволяющий собирать весь фронт в одну папку.
  Использование пресетов и плагинов для упрощения работы. Яркий пример для поддержки проекта - вся статика хешируется в именах,
  чтобы пользователи всегда получали актуальные файлы.

  Использование Git, либо другой VCS. Ключевой элемент в разработке. Контроль над изменением функциональности и ростом проекта.
  Каждый шаг в разработке отслеживается. Всегда можно откатиться. Безопасный и гибкий процесс роста приложения - это VCS.

  Про проблемы. Обычно, если проблема возникает, то она либо уже решена кем-то, и решение можно найти в паутине, либо решается
  освежением в памяти документации. В ином случае решается бессонной ночью и глубоким обумыванием.

  Одна из последних. В тестовом задании нужно было создать онлайн-табло аэропорта с поиском и сортировками. Данные получать 
  с открытого API. Дело в том, что такие точные данные не выдаются просто так. Нужно регистрироваться как ИП, либо покупать доступ.
  Сроки ограничены. Нужно где-то брать данные аэропорта. Через iframe и jsonp не получалось, да и уникальный ключ нужен. Нашёл выход -
  с бекэнда грабить таблицу с сайта нужно аэропорта, как элемент DOM. Чистить данные с regExp и отправлять во фронт.

Q3 "Presentational/Container Components"

  Это идея разделения компонентов по поведению.

  Presentational C. - имеет свои стили, черпает состояние и колбеки через пропсы,
  часто представляет собой функциональный компонент, редко имеет состояние и жизненные циклы.
  
  Container C. - не должен иметь стилей, имеет свое состояние, либо подписан на Redux state.
  Передает данные  и колбеки в дочерние компоненты.
  
  Оба вида контейнеров могут содержать в себе как презентационные, так и компоненты контейнеры.
  Основная выгода состоит в том, что код можно переиспользовать. А разделение логики помогает лушче ориентироваться
  и быстрее искать ошибки в коде.

  Минусы тоже имеются. Можно запутаться в большом количестве разделений, особенно если они сделаны неправилно.
  Также тратится больше времени на обдумывание разделении логики.

Q4 "Наследование в JS"

  В js используется прототипное наследование. Любой созданный в js среде объект уже имеет методы, даже если он пустой.
  Так происходит, потому что у каждого объекта, есть скрытое свойство __proto__, где находится ссылка на прототип родительского объекта.
  Вершиной иерархии объектов является object Object, у которого __proto__ равен null. Кроссбраузерный способ установки
  значения в в __proto__ - Object.create() //  Child.prototype = Object.create(Parent.prototype)

  Свойства объектов наследуются путем запуска конструктора родителя в контексте данного объекта, используя call или apply.
  
  ES6 упрощает работу с классами, но это всего лишь синтаксический сахар, и в итоге движок JS всё равно создает функции.
  Множественного наследования в JS нет, но можно сделать что-то похоже используя примеси.

  Небольшой пример : 

function Animal(name, size) {
    this.size = size;
    this.name = name;
}

Animal.prototype.breathe = function () {
    console.log("I can breathe")
};

Animal.prototype.getDescription = function () {
    console.log(`My size is ${this.size} and name is ${this.name}`)
};

function Bird(size, name) {
    Animal.apply(this, [size,name])
}

Bird.prototype = Object.create(Animal.prototype);
Bird.prototype.constructor = Bird;
Bird.prototype.fly = function () {
    console.log("i believe i can fly")
};

function Fish(size, name) {
    Animal.apply(this, [size, name])
}

Fish.prototype = Object.create(Animal.prototype);
Fish.prototype.constructor = Fish;
Fish.prototype.swim = function () {
    console.log("I can swim")
};
Fish.prototype.dive = function () {
    console.log("I can dive")
};

function Monster(name, size) {
    Animal.apply(this, [name, size])
}

Monster.prototype = Object.create(Animal.prototype);
Monster.prototype.constructor = Monster;

function mixin(target, parentClass) {
    for (var i in parentClass.prototype) {
        if (parentClass.prototype.hasOwnProperty(i)) {
            target.prototype[i] = parentClass.prototype[i]
        }
    }
}

mixin(Monster, Fish);
mixin(Monster, Bird);

var foo = new Monster("Boom", 23);
foo.dive(); // I can dive
foo.swim(); // I can swim
foo.fly(); // I believe i can fly
foo.getDescription(); // My size is 23 and name is Boom

В итоге мы унаследовали все методы у Bird и Fish,
при это являясь прямым потомком Animal. Теперь наш Monster умеет всё.

Q5 "E2E тестирование"

  Честно скажу, что руки до этого не доходили.
  Видел, как работает Cypress, круто, но лично не щупал.
  Осведомлен о пирамиде тестирования. Юнит тесты - интеграционные тесты - UI
  
Q6 "Действия при отсутсвии описания поведения" 
  
  При такой постановке условия я сначала попытаюсь уточнить у заказчика, какое поведение
  должно быть у полей и какая динамика. Если же вариантов связаться нет, а что-то предпринять нужно, то
  я создам отдельную ветку в гите и сделаю там стандартную динамику, чтобы страница была живой.
  На выходе будет из чего выбрать. Вообще такие вопросы нужно стараться уточнять заранее. 
  
Q7 "Инструменты, помогающие в работе экономить время"

  Сама IDE является безумным инструментом для экономии времени в работе(в моём случае WebStorm). Debug, интеграция с git и базой данных,
  быстрые перемещения, hotkeys, корректор слов, автодополнение, консоль и тд. Помимо этого основным помошником
  является панель разработчика в браузере. Также выручают полезные расширения - React Developer Tools, Redux DevTools.
  Webpack - мощная вещь для сборки. Не представляю сколько времени можно потратить, если не использовать возможности сборщиков.
  webpack-dev-server c hotreload, nodemon.

Q8 "Ресуры для развития и области знаний вне работы"
  
  Мой любимы ресурс это medium.com. Очень много полезных вещей я узнал оттуда.
  Конечно же Stack Overflow. Иногда хабр и тостер. GitHub - как средство развития в процессе чтения чужого кода.
  Некоторые паблики в соц.сетях делают неплохие подборки статей на разные темы - For Web, ITmozg
  В телеграме неплохой канал UniLecs - дают задачи, а после разбирают.
  Книги, офф. документации и ютуб.
  
  Насчёт других областей. Интересен SMM и PR нестандартных проектов.
  Обычно музыкальные кол-вы и их мероприятия, в общем всё то, что тяжело продать.
  То, где нужен нестандартный подход к людям.

Q9 "О себе и последних работах."
  
  Я обычный парень со своими сильными и слабыми сторонами. Общительный. Могу поговорить и о видах полиморфизма,
  и о поражении Конора МакГрегора. К работе отношусь серьезно. Готов неистово пахать, так как учиться и набираться опыта можно             бесконечно. И это интересно. Бывший фокусник-иллюзионист со стажем в 5 лет работы. Не знаю, что такое похмелье :)
  О качествах вида "пунктуальный, усидчивый и тд" не вижу смысла писать, так как всё это проверяется временем.
  
  Пару последних работ: 
    
    Сайт рок-группы - https://kvartetdostoevskogo.herokuapp.com/  - Находится в режиме сна. Поэтому при первой загрузе нужно подождать.
    Код - https://github.com/Scvoll/siteSPArockBand

    Публичный чат на сокетах - https://github.com/Scvoll/socketChat
